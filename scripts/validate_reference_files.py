#!/usr/bin/env python3
"""
Reference File Validation Script

This script validates that the Rust MP3 encoder can reproduce all reference files
generated by the Shine encoder. It runs comprehensive tests across all configurations
to ensure complete compatibility.

Usage:
    python scripts/validate_reference_files.py [options]
"""

import os
import sys
import subprocess
import hashlib
import json
import argparse
from pathlib import Path
from typing import Dict, List, Tuple, Optional

class ReferenceFileValidator:
    """Validates Rust encoder output against Shine reference files."""
    
    def __init__(self, workspace_root: str = "."):
        self.workspace_root = Path(workspace_root).resolve()
        self.audio_dir = self.workspace_root / "tests" / "audio"
        self.manifest_file = self.audio_dir / "reference_manifest.json"
        
    def load_manifest(self) -> Dict:
        """Load the reference file manifest."""
        if not self.manifest_file.exists():
            raise FileNotFoundError(f"Manifest file not found: {self.manifest_file}")
        
        with open(self.manifest_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def calculate_sha256(self, file_path: Path) -> str:
        """Calculate SHA256 hash of a file."""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256_hash.update(chunk)
        return sha256_hash.hexdigest()
    
    def get_input_file_from_config(self, config_name: str) -> Optional[str]:
        """Extract input file name from config name and known patterns."""
        if "voice" in config_name:
            return "voice-recorder-testing-1-2-3-sound-file.wav"
        elif "large" in config_name:
            return "Free_Test_Data_500KB_WAV.wav"
        else:
            return "sample-3s.wav"
    
    def get_frame_limit_from_config(self, config_name: str) -> Optional[int]:
        """Extract frame limit from config name."""
        if "1frame" in config_name:
            return 1
        elif "2frames" in config_name:
            return 2
        elif "3frames" in config_name:
            return 3
        elif "6frames" in config_name:
            return 6
        elif "10frames" in config_name:
            return 10
        elif "15frames" in config_name:
            return 15
        elif "20frames" in config_name:
            return 20
        return None
    
    def run_rust_encoder(self, input_file: str, output_file: str, 
                        frame_limit: Optional[int] = None) -> Tuple[bool, str]:
        """Run the Rust encoder with specified parameters."""
        input_path = self.audio_dir / input_file
        
        if not input_path.exists():
            return False, f"Input file not found: {input_path}"
        
        cmd = ["cargo", "run", "--", str(input_path), output_file]
        
        # Set up environment
        env = os.environ.copy()
        if frame_limit is not None:
            env["RUST_MP3_MAX_FRAMES"] = str(frame_limit)
        
        try:
            result = subprocess.run(
                cmd,
                cwd=self.workspace_root,
                capture_output=True,
                text=True,
                timeout=30,
                env=env
            )
            
            if result.returncode == 0:
                return True, result.stdout
            else:
                return False, f"Exit code {result.returncode}: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "Timeout expired"
        except Exception as e:
            return False, str(e)
    
    def validate_single_reference(self, config_name: str, reference_info: Dict) -> Dict:
        """Validate a single reference file against Rust output."""
        print(f"\nüîç Validating {config_name}...")
        print(f"   Description: {reference_info['description']}")
        
        # Extract configuration details
        input_file = self.get_input_file_from_config(config_name)
        frame_limit = self.get_frame_limit_from_config(config_name)
        reference_path = Path(reference_info['file_path'])
        
        if not reference_path.exists():
            return {
                "config": config_name,
                "success": False,
                "error": f"Reference file not found: {reference_path}"
            }
        
        # Generate Rust output
        rust_output = f"validate_{config_name}.mp3"
        rust_success, rust_message = self.run_rust_encoder(
            input_file, rust_output, frame_limit
        )
        
        if not rust_success:
            return {
                "config": config_name,
                "success": False,
                "error": f"Rust encoder failed: {rust_message}"
            }
        
        # Compare files
        rust_path = Path(rust_output)
        if not rust_path.exists():
            return {
                "config": config_name,
                "success": False,
                "error": f"Rust output file not created: {rust_path}"
            }
        
        # Check file sizes
        rust_size = rust_path.stat().st_size
        reference_size = reference_info['size_bytes']
        
        if rust_size != reference_size:
            # Clean up
            rust_path.unlink()
            return {
                "config": config_name,
                "success": False,
                "error": f"Size mismatch: Rust={rust_size}, Reference={reference_size}"
            }
        
        # Check hashes
        rust_hash = self.calculate_sha256(rust_path)
        reference_hash = reference_info['sha256']
        
        # Clean up
        rust_path.unlink()
        
        if rust_hash != reference_hash:
            return {
                "config": config_name,
                "success": False,
                "error": f"Hash mismatch: Rust={rust_hash[:16]}..., Reference={reference_hash[:16]}..."
            }
        
        print(f"   ‚úÖ Validation successful")
        print(f"      Size: {rust_size} bytes")
        print(f"      Hash: {rust_hash[:16]}...")
        
        return {
            "config": config_name,
            "success": True,
            "size": rust_size,
            "hash": rust_hash,
            "input_file": input_file,
            "frame_limit": frame_limit
        }
    
    def validate_all_references(self, configs: Optional[List[str]] = None) -> Dict:
        """Validate all reference files or specified configs."""
        print("üöÄ Starting reference file validation...")
        print(f"   Workspace: {self.workspace_root}")
        
        # Load manifest
        try:
            manifest = self.load_manifest()
        except Exception as e:
            print(f"‚ùå Failed to load manifest: {e}")
            return {"success": False, "error": str(e)}
        
        reference_files = manifest.get("reference_files", {})
        
        # Filter configs if specified
        if configs:
            available_configs = set(reference_files.keys())
            requested_configs = set(configs)
            missing_configs = requested_configs - available_configs
            
            if missing_configs:
                print(f"‚ùå Unknown configs: {missing_configs}")
                print(f"   Available configs: {list(available_configs)}")
                return {"success": False, "error": f"Unknown configs: {missing_configs}"}
            
            reference_files = {k: v for k, v in reference_files.items() if k in configs}
        
        print(f"   Validating {len(reference_files)} reference files...")
        
        # Validate each reference file
        results = []
        for config_name, reference_info in reference_files.items():
            result = self.validate_single_reference(config_name, reference_info)
            results.append(result)
        
        # Summary
        successful = [r for r in results if r["success"]]
        failed = [r for r in results if not r["success"]]
        
        print(f"\nüìä Validation Summary:")
        print(f"   ‚úÖ Successful: {len(successful)}")
        print(f"   ‚ùå Failed: {len(failed)}")
        
        if failed:
            print("\n‚ùå Failed validations:")
            for result in failed:
                print(f"   - {result['config']}: {result['error']}")
        
        if successful:
            print("\n‚úÖ Successful validations:")
            for result in successful:
                frame_info = f" ({result['frame_limit']} frames)" if result.get('frame_limit') else ""
                print(f"   - {result['config']}: {result['size']} bytes{frame_info}")
        
        return {
            "success": len(failed) == 0,
            "total": len(results),
            "successful": len(successful),
            "failed": len(failed),
            "results": results
        }

def main():
    parser = argparse.ArgumentParser(
        description="Validate Rust encoder output against Shine reference files"
    )
    parser.add_argument(
        "--configs", 
        nargs="+", 
        help="Specific configs to validate (default: all)"
    )
    parser.add_argument(
        "--workspace", 
        default=".",
        help="Workspace root directory (default: current directory)"
    )
    
    args = parser.parse_args()
    
    validator = ReferenceFileValidator(args.workspace)
    result = validator.validate_all_references(configs=args.configs)
    
    if result["success"]:
        print("\nüéâ All validations passed!")
        print("The Rust encoder produces identical output to Shine for all tested configurations.")
        sys.exit(0)
    else:
        print("\nüí• Some validations failed!")
        print("Please check the errors above and fix the Rust implementation.")
        sys.exit(1)

if __name__ == "__main__":
    main()