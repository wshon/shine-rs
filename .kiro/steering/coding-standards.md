---
inclusion: always
---

# 编码规范

## 项目架构原则

### MP3编码器实现标准
- **算法逻辑与 ref/shine 保持一致** - 这是一个MP3编码器项目，所有算法逻辑必须与 `ref/shine/` 目录下的C实现保持一致
- 查找表、常量、计算公式必须与shine源码完全对应
- 算法步骤和数据流应镜像shine的实现逻辑
- 数值精度要求与shine保持一致，特别是量化和MDCT计算

### Shine算法一致性要求
- **算法逻辑一致性**: 
  - 函数的核心算法逻辑必须与shine中对应函数保持一致
  - 参数类型、顺序、数量必须对应shine的函数签名
  - 返回值类型必须与shine保持语义一致
- **数学计算一致性**:
  - 循环结构、条件判断、计算顺序完全一致
  - 位运算、移位操作必须与shine保持一致
  - 数学计算的精度和舍入方式必须相同
- **数据结构对应**:
  - C的`int`对应Rust的`i32`，`unsigned int`对应`u32`
  - C的`float`对应Rust的`f32`，`double`对应`f64`
  - 数组大小和索引范围必须与shine完全一致
- **常量定义一致**:
  - 实现与shine相同的宏定义（使用Rust的`const`或`macro_rules!`）
  - 常量值必须与shine源码中的值完全相同
  - 查找表必须与shine的表格逐个元素对应

### 现代Rust代码风格
- **优先使用现代Rust惯用法**:
  - 使用迭代器和函数式编程风格（`map`, `fold`, `filter`等）
  - 优先使用`enumerate()`而不是手动索引循环
  - 使用切片操作和范围语法
  - 利用Rust的所有权系统避免不必要的克隆
- **代码可读性优化**:
  - 使用有意义的变量名和函数名（遵循Rust命名规范）
  - 适当使用模式匹配和解构
  - 利用类型推断减少冗余类型注解
  - 使用`?`操作符进行错误传播
- **性能优化的现代写法**:
  - 使用`Vec::with_capacity`预分配内存
  - 优先使用`&str`而不是`String`作为参数
  - 使用`const fn`定义编译时常量
  - 合理使用`inline`属性优化热点函数

### 平衡原则
- **算法核心不变**: shine的核心算法逻辑（数学计算、循环逻辑、条件判断）必须保持不变
- **实现方式现代化**: 在保证算法逻辑一致的前提下，使用现代Rust写法提高代码质量
- **性能与可读性并重**: 既要保证MP3编码的性能要求，也要保持代码的可读性和可维护性
- **渐进式改进**: 可以逐步将旧代码重构为现代Rust风格，但必须通过测试验证算法一致性

### 问题调试规范
- **优先查看 shine 原始实现** - 遇到算法问题时，第一时间查看 `ref/shine/src/lib/` 中对应的C语言实现
- **不要擅自调整算法逻辑** - 发现问题时不要凭经验修改算法，必须参考shine的具体实现逻辑
- **可以优化实现方式** - 在保证算法逻辑一致的前提下，可以使用更现代的Rust写法
- **测试驱动重构** - 任何代码风格改进都必须通过现有测试，确保算法行为不变
- **逐步现代化** - 可以将C风格的循环改写为迭代器风格，但必须保证计算结果完全一致

### 模块组织架构
- **核心模块**: `bitstream`, `encoder`, `huffman`, `mdct`, `quantization`, `reservoir`, `subband`, `tables`
- **配置模块**: `config` - 编码参数和设置
- **错误处理**: `error` - 统一的错误类型定义
- 每个模块专注单一职责，文件大小控制在合理范围内
- 模块间通过明确的接口通信，避免循环依赖

## 代码质量要求

### 编译和静态检查
- **零警告政策** - 使用 `getDiagnostics` 工具检查，必须修复所有编译警告
- 运行 `cargo clippy` 并修复所有建议，优先采用clippy的现代化建议
- 使用 `cargo check` 验证编译通过
- 代码提交前必须通过所有静态检查

### 现代Rust代码风格
- **命名约定**:
  - 变量和函数: `snake_case`
  - 结构体和枚举: `PascalCase`
  - 常量: `SCREAMING_SNAKE_CASE`
  - 模块名: `snake_case`
- **现代化写法示例**:
  ```rust
  // ✅ 现代Rust风格
  for (i, value) in array.iter().enumerate() {
      process(i, *value);
  }
  
  let max = values.iter().fold(0, |acc, &val| acc.max(val));
  
  // ❌ 避免的C风格写法
  for i in 0..array.len() {
      process(i, array[i]);
  }
  
  let mut max = 0;
  for i in 0..values.len() {
      if max < values[i] { max = values[i]; }
  }
  ```

### 错误处理模式
- 使用 `Result<T, E>` 进行错误传播
- 自定义错误类型在 `src/error.rs` 中定义
- 优先使用`?`操作符而不是`unwrap()`和`expect()`
- 错误信息应简洁明确，便于调试

### 文档和注释
- 所有公共API必须有 `///` 文档注释
- 复杂算法需要解释其在MP3编码中的作用
- 引用shine源码时注明对应文件和函数名
- 算法实现的关键步骤需要内联注释

## 开发工作流

### 代码修改流程
1. **查看shine源码** - 首先查看 `ref/shine/src/lib/` 中对应的C实现
2. **理解shine逻辑** - 完全理解shine的算法逻辑、数据流和函数调用关系
3. **使用 `getDiagnostics` 检查现有代码状态**
4. **实现算法逻辑** - 保证算法逻辑与shine一致，但使用现代Rust写法
5. **运行clippy检查** - 采用clippy建议的现代化改进
6. **与shine输出对比验证** - 使用相同输入验证输出完全一致
7. **运行相关测试验证功能正确性**
8. **确保无编译警告和错误**

### 重构指导原则
- **测试先行**: 重构前确保有充分的测试覆盖
- **小步快跑**: 每次只重构一小部分，立即验证测试通过
- **保持接口稳定**: 重构内部实现，但保持公共接口不变
- **性能验证**: 重构后验证性能没有显著下降

### 测试策略
- 每个算法模块都需要单元测试
- 关键算法需要与shine输出进行对比测试
- 使用 `proptest` 进行属性测试和边界条件验证
- 集成测试验证完整的编码流程

### 性能考虑
- MP3编码是计算密集型任务，优先考虑算法正确性
- 在保证正确性前提下使用现代Rust优化性能
- 使用 `cargo bench` 进行性能基准测试
- 合理使用零成本抽象提高代码质量

## Shine对应关系维护

### 算法逻辑对应关系
- 编码器主流程的算法步骤与shine完全对应
- 量化算法的数学计算与shine完全对应
- MDCT变换的计算逻辑与shine完全对应
- 所有查找表和常量与shine完全对应

### 现代化改进示例
```rust
// Shine C代码风格
for i in 0..GRANULE_SIZE {
    if max < ix[i] { max = ix[i]; }
}

// 现代Rust风格（保持相同逻辑）
let max = ix.iter().take(GRANULE_SIZE).fold(0, |acc, &val| acc.max(val));
```

### 验证要求
- 每个函数重构后必须通过单元测试验证与shine输出一致
- 关键算法必须通过数值精度测试
- 完整编码流程必须与shine生成相同的MP3文件
- 性能测试确保现代化改进没有性能损失